<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self' data:;">
  <title>Max's Spreadsheet</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      background: #1a1a2e;
    }

    /* Max's Spreadsheet Header */
    #max-header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 38px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      -webkit-app-region: drag;
      user-select: none;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    }

    #max-header .logo {
      width: 20px;
      height: 20px;
      background: white;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-right: 8px;
      font-weight: bold;
      font-size: 12px;
      color: #764ba2;
    }

    #max-header .title {
      color: white;
      font-size: 13px;
      font-weight: 600;
      letter-spacing: 0.3px;
    }

    #max-header .subtitle {
      color: rgba(255,255,255,0.8);
      font-size: 11px;
      margin-left: 8px;
    }

    #max-header .file-name {
      position: absolute;
      right: 80px;
      color: rgba(255,255,255,0.9);
      font-size: 11px;
      max-width: 200px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    #max-header .modified-indicator {
      color: #ffd700;
      margin-left: 4px;
    }

    /* Formula Bar */
    #formula-bar {
      position: fixed;
      top: 38px;
      left: 0;
      right: 0;
      height: 32px;
      background: #f8f9fa;
      border-bottom: 1px solid #e0e0e0;
      display: flex;
      align-items: center;
      padding: 0 8px;
      z-index: 999;
      gap: 8px;
    }

    #formula-bar .cell-ref {
      min-width: 60px;
      padding: 4px 10px;
      background: white;
      border: 1px solid #d0d0d0;
      border-radius: 4px;
      font-family: 'SF Mono', Monaco, 'Courier New', monospace;
      font-size: 12px;
      font-weight: 600;
      color: #333;
      text-align: center;
    }

    #formula-bar .fx-icon {
      font-style: italic;
      font-weight: bold;
      color: #666;
      font-size: 14px;
      padding: 0 4px;
    }

    #formula-bar .formula-input {
      flex: 1;
      padding: 4px 10px;
      background: white;
      border: 1px solid #d0d0d0;
      border-radius: 4px;
      font-family: 'SF Mono', Monaco, 'Courier New', monospace;
      font-size: 12px;
      color: #333;
      outline: none;
    }

    #formula-bar .formula-input:focus {
      border-color: #667eea;
      box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.2);
    }

    #formula-bar .formula-input::placeholder {
      color: #999;
    }

    /* Spreadsheet container */
    #spreadsheet-container {
      position: fixed;
      top: 70px; /* 38px header + 32px formula bar */
      left: 0;
      right: 0;
      bottom: 0;
      background: white;
      overflow: auto;
    }

    /* Loading state */
    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      color: #666;
    }

    #loading .spinner {
      width: 40px;
      height: 40px;
      border: 3px solid #f3f3f3;
      border-top: 3px solid #764ba2;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 16px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* FortuneSheet overrides */
    .fortune-sheet-container {
      width: 100% !important;
      height: 100% !important;
    }
  </style>
</head>
<body>
  <!-- Header -->
  <div id="max-header">
    <div class="logo">M</div>
    <span class="title">Max's Spreadsheet</span>
    <span class="subtitle">Excel-like Editor</span>
    <span class="file-name" id="file-name">Untitled</span>
  </div>

  <!-- Formula Bar -->
  <div id="formula-bar">
    <div class="cell-ref" id="cell-ref">A1</div>
    <span class="fx-icon">fx</span>
    <input type="text" class="formula-input" id="formula-input" placeholder="Enter value or formula (e.g., =SUM(A1:A10))">
  </div>

  <!-- Spreadsheet Container -->
  <div id="spreadsheet-container">
    <div id="loading">
      <div class="spinner"></div>
      <div>Loading spreadsheet...</div>
    </div>
    <div id="fortune-sheet"></div>
  </div>

  <script type="module">
    // FortuneSheet will be loaded dynamically
    // For now, we'll create a basic spreadsheet implementation
    // that can be enhanced with FortuneSheet later

    let spreadsheetData = [{
      name: 'Sheet1',
      celldata: [],
      row: 100,
      column: 26,
      config: {}
    }];

    let currentSheet = 'Sheet1';
    let isModified = false;
    let fortuneSheetInstance = null;
    let selectedCell = { row: 0, col: 0 }; // Track currently selected cell

    // Initialize the spreadsheet
    async function initSpreadsheet() {
      console.log('[Spreadsheet] Initializing...');

      try {
        // Try to dynamically import FortuneSheet
        // Note: This requires the package to be bundled properly
        // For now, we'll use a fallback grid implementation
        await initFallbackGrid();
      } catch (e) {
        console.error('[Spreadsheet] Failed to load FortuneSheet:', e);
        await initFallbackGrid();
      }

      // Initialize formula bar
      initFormulaBar();

      // Set initial formula bar state for A1
      updateFormulaBar(0, 0);

      // Hide loading indicator
      document.getElementById('loading').style.display = 'none';
    }

    // Fallback grid implementation (basic but functional)
    async function initFallbackGrid() {
      const container = document.getElementById('fortune-sheet');
      container.innerHTML = '';

      // Create a simple grid
      const grid = document.createElement('div');
      grid.id = 'simple-grid';
      grid.style.cssText = `
        width: fit-content;
        min-width: 100%;
        background: white;
        font-family: Arial, sans-serif;
        font-size: 13px;
      `;

      // Create table
      const table = document.createElement('table');
      table.style.cssText = `
        border-collapse: collapse;
        min-width: 100%;
      `;

      // Create header row (A, B, C, ...)
      const thead = document.createElement('thead');
      const headerRow = document.createElement('tr');

      // Empty corner cell
      const cornerCell = document.createElement('th');
      cornerCell.style.cssText = `
        width: 50px;
        min-width: 50px;
        background: #f5f5f5;
        border: 1px solid #e0e0e0;
        position: sticky;
        top: 0;
        left: 0;
        z-index: 3;
      `;
      headerRow.appendChild(cornerCell);

      // Column headers
      for (let c = 0; c < 26; c++) {
        const th = document.createElement('th');
        th.textContent = String.fromCharCode(65 + c);
        th.style.cssText = `
          width: 100px;
          min-width: 100px;
          background: #f5f5f5;
          border: 1px solid #e0e0e0;
          padding: 4px 8px;
          font-weight: 500;
          position: sticky;
          top: 0;
          z-index: 2;
        `;
        headerRow.appendChild(th);
      }
      thead.appendChild(headerRow);
      table.appendChild(thead);

      // Create body with 100 rows
      const tbody = document.createElement('tbody');
      for (let r = 0; r < 100; r++) {
        const row = document.createElement('tr');

        // Row number
        const rowHeader = document.createElement('td');
        rowHeader.textContent = r + 1;
        rowHeader.style.cssText = `
          background: #f5f5f5;
          border: 1px solid #e0e0e0;
          padding: 4px 8px;
          text-align: center;
          font-weight: 500;
          position: sticky;
          left: 0;
          z-index: 1;
        `;
        row.appendChild(rowHeader);

        // Cells
        for (let c = 0; c < 26; c++) {
          const cell = document.createElement('td');
          cell.contentEditable = true;
          cell.dataset.row = r;
          cell.dataset.col = c;
          cell.style.cssText = `
            border: 1px solid #e0e0e0;
            padding: 4px 8px;
            min-width: 100px;
            outline: none;
          `;

          // Track if user is actively editing the cell
          let cellWasEdited = false;

          // Handle cell selection and editing
          cell.addEventListener('focus', () => {
            selectedCell = { row: r, col: c };
            cellWasEdited = false; // Reset edit flag on focus
            cell.style.background = '#e8f0fe';
            cell.style.outline = '2px solid #667eea';
            updateFormulaBar(r, c);
          });

          cell.addEventListener('blur', () => {
            const value = cell.textContent;
            const existingData = getCellDataInternal(currentSheet, r, c);

            // If user edited the cell directly, check if they typed a formula or plain value
            if (cellWasEdited) {
              if (value.startsWith('=')) {
                // User typed a formula - use setCellFormula to properly store it
                window.setCellFormula(currentSheet, r, c, value);
              } else {
                // User typed a plain value - replace any existing formula
                setCellDataInternal(currentSheet, r, c, value);
                updateFileModified(true);
              }
            } else if (existingData?.v?.f) {
              // Cell wasn't edited and has a formula - preserve it and recalculate
              const recalculated = evaluateFormula(existingData.v.f, currentSheet);
              if (recalculated !== existingData.v.v) {
                existingData.v.v = recalculated;
              }
            }
            // If not edited and no formula, nothing to do - value is already saved

            cell.style.background = '';
            cell.style.outline = '';
          });

          // Handle input for formula bar sync
          cell.addEventListener('input', () => {
            // Mark that user is actively editing this cell
            cellWasEdited = true;
            // Sync cell content to formula bar as user types
            document.getElementById('formula-input').value = cell.textContent;
          });

          // Load existing data
          const cellData = getCellDataInternal(currentSheet, r, c);
          if (cellData) {
            cell.textContent = cellData.v?.v || cellData.v || '';
          }

          row.appendChild(cell);
        }

        tbody.appendChild(row);
      }
      table.appendChild(tbody);
      grid.appendChild(table);
      container.appendChild(grid);

      console.log('[Spreadsheet] Fallback grid initialized');
    }

    // Internal cell data functions
    function getCellDataInternal(sheetName, row, col) {
      const sheet = spreadsheetData.find(s => s.name === sheetName);
      if (!sheet || !sheet.celldata) return null;
      return sheet.celldata.find(c => c.r === row && c.c === col);
    }

    function setCellDataInternal(sheetName, row, col, value) {
      const sheet = spreadsheetData.find(s => s.name === sheetName);
      if (!sheet) return;

      if (!sheet.celldata) sheet.celldata = [];

      const existingIndex = sheet.celldata.findIndex(c => c.r === row && c.c === col);
      const cellData = {
        r: row,
        c: col,
        v: typeof value === 'object' ? value : { v: value }
      };

      if (existingIndex >= 0) {
        sheet.celldata[existingIndex] = cellData;
      } else {
        sheet.celldata.push(cellData);
      }
    }

    function updateFileModified(modified) {
      isModified = modified;
      const indicator = document.querySelector('.modified-indicator');
      if (indicator) {
        indicator.style.display = modified ? 'inline' : 'none';
      } else if (modified) {
        const fileName = document.getElementById('file-name');
        const span = document.createElement('span');
        span.className = 'modified-indicator';
        span.textContent = '*';
        fileName.appendChild(span);
      }
    }

    // Update the formula bar when a cell is selected
    function updateFormulaBar(row, col) {
      const cellRef = document.getElementById('cell-ref');
      const formulaInput = document.getElementById('formula-input');

      // Convert row/col to A1 notation
      const colLetter = String.fromCharCode(65 + col);
      const rowNumber = row + 1;
      cellRef.textContent = `${colLetter}${rowNumber}`;

      // Get the cell data - show formula if present, otherwise show value
      const cellData = getCellDataInternal(currentSheet, row, col);
      if (cellData?.v?.f) {
        // Cell has a formula - show the formula
        formulaInput.value = cellData.v.f;
      } else if (cellData?.v?.v != null) {
        // Cell has a value object
        formulaInput.value = cellData.v.v;
      } else if (cellData?.v != null) {
        // Cell has a direct value
        formulaInput.value = cellData.v;
      } else {
        // Empty cell
        formulaInput.value = '';
      }
    }

    // Initialize formula bar event handlers
    function initFormulaBar() {
      const formulaInput = document.getElementById('formula-input');

      // Handle Enter key in formula bar
      formulaInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          applyFormulaBarValue();
          // Move focus back to the cell
          const cell = document.querySelector(`td[data-row="${selectedCell.row}"][data-col="${selectedCell.col}"]`);
          if (cell) cell.focus();
        } else if (e.key === 'Escape') {
          // Cancel editing and restore original value
          updateFormulaBar(selectedCell.row, selectedCell.col);
          const cell = document.querySelector(`td[data-row="${selectedCell.row}"][data-col="${selectedCell.col}"]`);
          if (cell) cell.focus();
        }
      });

      // Handle blur - apply value when focus leaves formula bar
      formulaInput.addEventListener('blur', () => {
        // Only apply if the value changed
        const currentValue = formulaInput.value;
        const cellData = getCellDataInternal(currentSheet, selectedCell.row, selectedCell.col);
        const existingValue = cellData?.v?.f || cellData?.v?.v || cellData?.v || '';

        if (currentValue !== existingValue.toString()) {
          applyFormulaBarValue();
        }
      });
    }

    // Apply the formula bar value to the selected cell
    function applyFormulaBarValue() {
      const formulaInput = document.getElementById('formula-input');
      const value = formulaInput.value;
      const { row, col } = selectedCell;

      if (value.startsWith('=')) {
        // It's a formula
        window.setCellFormula(currentSheet, row, col, value);
      } else {
        // It's a regular value
        window.setCellValue(currentSheet, row, col, value);
      }

      // Update the cell display
      const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
      if (cell) {
        const cellData = getCellDataInternal(currentSheet, row, col);
        cell.textContent = cellData?.v?.v ?? cellData?.v ?? value;
      }
    }

    // Expose functions to the preload script
    window.getSpreadsheetData = () => spreadsheetData;

    window.setSpreadsheetData = (data) => {
      spreadsheetData = data;
      // Re-render the grid with new data
      initFallbackGrid();
    };

    window.getCellValue = (sheet, row, col) => {
      const cellData = getCellDataInternal(sheet, row, col);
      if (!cellData) return { value: null, formula: null };
      return {
        value: cellData.v?.v ?? cellData.v,
        formula: cellData.v?.f || null
      };
    };

    window.setCellValue = (sheet, row, col, value) => {
      setCellDataInternal(sheet, row, col, value);
      updateFileModified(true);

      // Update the DOM
      const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
      if (cell) {
        cell.textContent = value;
      }
    };

    window.getRangeValues = (sheet, startRow, startCol, endRow, endCol) => {
      const result = [];
      for (let r = startRow; r <= endRow; r++) {
        const row = [];
        for (let c = startCol; c <= endCol; c++) {
          const cellData = getCellDataInternal(sheet, r, c);
          row.push(cellData?.v?.v ?? cellData?.v ?? null);
        }
        result.push(row);
      }
      return result;
    };

    window.setRangeValues = (sheet, startRow, startCol, data) => {
      for (let r = 0; r < data.length; r++) {
        for (let c = 0; c < data[r].length; c++) {
          setCellDataInternal(sheet, startRow + r, startCol + c, data[r][c]);

          // Update the DOM
          const cell = document.querySelector(`td[data-row="${startRow + r}"][data-col="${startCol + c}"]`);
          if (cell) {
            cell.textContent = data[r][c];
          }
        }
      }
      updateFileModified(true);
    };

    window.setCellFormula = (sheet, row, col, formula) => {
      const sheetData = spreadsheetData.find(s => s.name === sheet);
      if (!sheetData) return;

      if (!sheetData.celldata) sheetData.celldata = [];

      const existingIndex = sheetData.celldata.findIndex(c => c.r === row && c.c === col);

      // Debug: store formula evaluation result
      let evalResult;
      try {
        evalResult = evaluateFormula(formula, sheet);
      } catch (e) {
        evalResult = '#ERROR!';
        window._formulaDebug = { formula, error: e.message, stack: e.stack };
      }
      if (evalResult === '#ERROR!' && window._lastFormulaError) {
        // Store for debugging
        window._formulaDebug = window._lastFormulaError;
      }

      const cellData = {
        r: row,
        c: col,
        v: { f: formula, v: evalResult }
      };

      if (existingIndex >= 0) {
        sheetData.celldata[existingIndex] = cellData;
      } else {
        sheetData.celldata.push(cellData);
      }

      // Update the DOM
      const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
      if (cell) {
        cell.textContent = cellData.v.v;
      }

      updateFileModified(true);
    };

    window.getCellFormula = (sheet, row, col) => {
      const cellData = getCellDataInternal(sheet, row, col);
      return cellData?.v?.f || null;
    };

    window.formatCells = (sheet, startRow, startCol, endRow, endCol, format) => {
      // Apply formatting to cells
      for (let r = startRow; r <= endRow; r++) {
        for (let c = startCol; c <= endCol; c++) {
          const cell = document.querySelector(`td[data-row="${r}"][data-col="${c}"]`);
          if (cell) {
            if (format.bold) cell.style.fontWeight = 'bold';
            if (format.italic) cell.style.fontStyle = 'italic';
            if (format.color) cell.style.color = format.color;
            if (format.background) cell.style.background = format.background;
            if (format.align) cell.style.textAlign = format.align;
          }
        }
      }
      updateFileModified(true);
    };

    window.getSheetNames = () => {
      return spreadsheetData.map(s => s.name);
    };

    window.addSheet = (name) => {
      spreadsheetData.push({
        name: name,
        celldata: [],
        row: 100,
        column: 26,
        config: {}
      });
      updateFileModified(true);
    };

    window.deleteSheet = (name) => {
      const index = spreadsheetData.findIndex(s => s.name === name);
      if (index > 0) { // Don't delete the first sheet
        spreadsheetData.splice(index, 1);
        updateFileModified(true);
      }
    };

    window.getSheetData = (sheetName) => {
      return spreadsheetData.find(s => s.name === sheetName);
    };

    // ============================================================
    // COMPREHENSIVE EXCEL FORMULA EVALUATOR
    // Supports 50+ Excel functions
    // ============================================================

    // Helper: Parse cell reference (e.g., "A1" -> {col: 0, row: 0})
    function parseCellRef(ref) {
      const match = ref.match(/^([A-Z]+)(\d+)$/);
      if (!match) return null;
      let col = 0;
      for (let i = 0; i < match[1].length; i++) {
        col = col * 26 + (match[1].charCodeAt(i) - 64);
      }
      return { col: col - 1, row: parseInt(match[2]) - 1 };
    }

    // Helper: Get cell value by reference string
    function getCellByRef(sheetName, ref) {
      const parsed = parseCellRef(ref);
      if (!parsed) return 0;
      const cellData = getCellDataInternal(sheetName, parsed.row, parsed.col);
      const val = cellData?.v?.v ?? cellData?.v;
      return val;
    }

    // Helper: Get numeric value from cell
    function getNumericValue(sheetName, ref) {
      const val = getCellByRef(sheetName, ref);
      const num = parseFloat(val);
      return isNaN(num) ? 0 : num;
    }

    // Helper: Get range values as flat array
    function getRangeValuesFlat(sheetName, start, end) {
      const s = parseCellRef(start);
      const e = parseCellRef(end);
      if (!s || !e) return [];
      const values = [];
      for (let r = s.row; r <= e.row; r++) {
        for (let c = s.col; c <= e.col; c++) {
          const cellData = getCellDataInternal(sheetName, r, c);
          values.push(cellData?.v?.v ?? cellData?.v);
        }
      }
      return values;
    }

    // Helper: Get numeric values from range
    function getNumericRange(sheetName, start, end) {
      return getRangeValuesFlat(sheetName, start, end)
        .map(v => parseFloat(v))
        .filter(v => !isNaN(v));
    }

    // Helper: Parse function arguments (handles nested functions)
    function parseArgs(argsStr) {
      const args = [];
      let depth = 0;
      let current = '';
      for (let i = 0; i < argsStr.length; i++) {
        const ch = argsStr[i];
        if (ch === '(') depth++;
        else if (ch === ')') depth--;
        else if (ch === ',' && depth === 0) {
          args.push(current.trim());
          current = '';
          continue;
        }
        current += ch;
      }
      if (current.trim()) args.push(current.trim());
      return args;
    }

    // Helper: Check if value matches criteria (for COUNTIF, SUMIF, etc.)
    function matchesCriteria(value, criteria) {
      if (typeof criteria === 'string') {
        // Handle comparison operators
        if (criteria.startsWith('>=')) return parseFloat(value) >= parseFloat(criteria.slice(2));
        if (criteria.startsWith('<=')) return parseFloat(value) <= parseFloat(criteria.slice(2));
        if (criteria.startsWith('<>')) return value != criteria.slice(2);
        if (criteria.startsWith('>')) return parseFloat(value) > parseFloat(criteria.slice(1));
        if (criteria.startsWith('<')) return parseFloat(value) < parseFloat(criteria.slice(1));
        if (criteria.startsWith('=')) return value == criteria.slice(1);
        // Wildcard support
        if (criteria.includes('*') || criteria.includes('?')) {
          const regex = new RegExp('^' + criteria.replace(/\*/g, '.*').replace(/\?/g, '.') + '$', 'i');
          return regex.test(String(value));
        }
        return String(value).toLowerCase() === String(criteria).toLowerCase();
      }
      return value == criteria;
    }

    // Helper: Evaluate a value that could be a number, cell ref, or nested formula
    function evalValue(val, sheetName) {
      if (val === undefined || val === null || val === '') return 0;
      const trimmed = String(val).trim();
      // Check if it's a quoted string
      if (trimmed.startsWith('"') && trimmed.endsWith('"')) {
        return trimmed.slice(1, -1);
      }
      // Check if it's a pure number (no operators or letters except E for scientific notation)
      if (/^-?\d+\.?\d*([eE][+-]?\d+)?$/.test(trimmed)) {
        return parseFloat(trimmed);
      }
      // Otherwise evaluate as formula/reference (handles expressions like 0.05/12)
      return evaluateFormula('=' + trimmed, sheetName);
    }

    // Main formula evaluator
    function evaluateFormula(formula, sheetName) {
      if (!formula || !formula.startsWith('=')) return formula;

      let expr = formula.substring(1).trim();

      // Handle pure number after = (must be ONLY digits, decimal, and optional scientific notation)
      if (/^-?\d+\.?\d*([eE][+-]?\d+)?$/.test(expr)) {
        return parseFloat(expr);
      }

      const exprUpper = expr.toUpperCase();

      try {
        // Extract function name and arguments (include digits for LOG10, etc.)
        const funcMatch = exprUpper.match(/^([A-Z_][A-Z_0-9]*)\((.*)\)$/s);
        // Also match original expr to preserve case in arguments
        const funcMatchOriginal = expr.match(/^([A-Za-z_][A-Za-z_0-9]*)\((.*)\)$/s);

        if (funcMatch) {
          const funcName = funcMatch[1];
          // Use original case args for text functions, uppercase for cell refs
          const argsStr = funcMatchOriginal ? funcMatchOriginal[2] : funcMatch[2];
          const args = parseArgs(argsStr);

          // ==================== MATH FUNCTIONS ====================

          // SUM - Add numbers
          if (funcName === 'SUM') {
            let total = 0;
            for (const arg of args) {
              if (arg.includes(':')) {
                const [start, end] = arg.split(':');
                total += getNumericRange(sheetName, start, end).reduce((a, b) => a + b, 0);
              } else if (parseCellRef(arg)) {
                total += getNumericValue(sheetName, arg);
              } else {
                total += parseFloat(evaluateFormula('=' + arg, sheetName)) || 0;
              }
            }
            return total;
          }

          // AVERAGE - Average of numbers
          if (funcName === 'AVERAGE') {
            let values = [];
            for (const arg of args) {
              if (arg.includes(':')) {
                const [start, end] = arg.split(':');
                values = values.concat(getNumericRange(sheetName, start, end));
              } else if (parseCellRef(arg)) {
                const v = getNumericValue(sheetName, arg);
                if (!isNaN(v)) values.push(v);
              } else {
                const v = parseFloat(evaluateFormula('=' + arg, sheetName));
                if (!isNaN(v)) values.push(v);
              }
            }
            return values.length > 0 ? values.reduce((a, b) => a + b, 0) / values.length : 0;
          }

          // COUNT - Count numbers
          if (funcName === 'COUNT') {
            let count = 0;
            for (const arg of args) {
              if (arg.includes(':')) {
                const [start, end] = arg.split(':');
                count += getNumericRange(sheetName, start, end).length;
              } else if (parseCellRef(arg)) {
                if (!isNaN(getNumericValue(sheetName, arg))) count++;
              }
            }
            return count;
          }

          // COUNTA - Count non-empty cells
          if (funcName === 'COUNTA') {
            let count = 0;
            for (const arg of args) {
              if (arg.includes(':')) {
                const [start, end] = arg.split(':');
                count += getRangeValuesFlat(sheetName, start, end).filter(v => v != null && v !== '').length;
              } else if (parseCellRef(arg)) {
                const v = getCellByRef(sheetName, arg);
                if (v != null && v !== '') count++;
              }
            }
            return count;
          }

          // COUNTBLANK - Count empty cells
          if (funcName === 'COUNTBLANK') {
            const [start, end] = args[0].split(':');
            return getRangeValuesFlat(sheetName, start, end).filter(v => v == null || v === '').length;
          }

          // MIN - Minimum value
          if (funcName === 'MIN') {
            let values = [];
            for (const arg of args) {
              if (arg.includes(':')) {
                const [start, end] = arg.split(':');
                values = values.concat(getNumericRange(sheetName, start, end));
              } else if (parseCellRef(arg)) {
                values.push(getNumericValue(sheetName, arg));
              } else {
                values.push(parseFloat(evaluateFormula('=' + arg, sheetName)) || 0);
              }
            }
            return values.length > 0 ? Math.min(...values) : 0;
          }

          // MAX - Maximum value
          if (funcName === 'MAX') {
            let values = [];
            for (const arg of args) {
              if (arg.includes(':')) {
                const [start, end] = arg.split(':');
                values = values.concat(getNumericRange(sheetName, start, end));
              } else if (parseCellRef(arg)) {
                values.push(getNumericValue(sheetName, arg));
              } else {
                values.push(parseFloat(evaluateFormula('=' + arg, sheetName)) || 0);
              }
            }
            return values.length > 0 ? Math.max(...values) : 0;
          }

          // ABS - Absolute value
          if (funcName === 'ABS') {
            return Math.abs(parseFloat(evaluateFormula('=' + args[0], sheetName)) || 0);
          }

          // SQRT - Square root
          if (funcName === 'SQRT') {
            const val = parseFloat(evalValue(args[0], sheetName)) || 0;
            return val >= 0 ? Math.sqrt(val) : '#NUM!';
          }

          // POWER - Power function
          if (funcName === 'POWER') {
            const base = parseFloat(evalValue(args[0], sheetName)) || 0;
            const exp = parseFloat(evalValue(args[1], sheetName)) || 0;
            return Math.pow(base, exp);
          }

          // MOD - Modulo
          if (funcName === 'MOD') {
            const num = parseFloat(evalValue(args[0], sheetName)) || 0;
            const divisor = parseFloat(evalValue(args[1], sheetName)) || 1;
            return num % divisor;
          }

          // ROUND - Round to decimal places
          if (funcName === 'ROUND') {
            const num = parseFloat(evalValue(args[0], sheetName)) || 0;
            const decimals = parseInt(evalValue(args[1], sheetName)) || 0;
            const factor = Math.pow(10, decimals);
            return Math.round(num * factor) / factor;
          }

          // ROUNDUP - Round up
          if (funcName === 'ROUNDUP') {
            const num = parseFloat(evaluateFormula('=' + args[0], sheetName)) || 0;
            const decimals = parseInt(args[1]) || 0;
            const factor = Math.pow(10, decimals);
            return Math.ceil(num * factor) / factor;
          }

          // ROUNDDOWN - Round down
          if (funcName === 'ROUNDDOWN') {
            const num = parseFloat(evaluateFormula('=' + args[0], sheetName)) || 0;
            const decimals = parseInt(args[1]) || 0;
            const factor = Math.pow(10, decimals);
            return Math.floor(num * factor) / factor;
          }

          // CEILING - Round up to multiple
          if (funcName === 'CEILING') {
            const num = parseFloat(evaluateFormula('=' + args[0], sheetName)) || 0;
            const sig = parseFloat(args[1]) || 1;
            return Math.ceil(num / sig) * sig;
          }

          // FLOOR - Round down to multiple
          if (funcName === 'FLOOR') {
            const num = parseFloat(evaluateFormula('=' + args[0], sheetName)) || 0;
            const sig = parseFloat(args[1]) || 1;
            return Math.floor(num / sig) * sig;
          }

          // INT - Round down to integer
          if (funcName === 'INT') {
            return Math.floor(parseFloat(evaluateFormula('=' + args[0], sheetName)) || 0);
          }

          // TRUNC - Truncate to integer or decimal places
          if (funcName === 'TRUNC') {
            const num = parseFloat(evaluateFormula('=' + args[0], sheetName)) || 0;
            const decimals = parseInt(args[1]) || 0;
            const factor = Math.pow(10, decimals);
            return Math.trunc(num * factor) / factor;
          }

          // SIGN - Sign of number (-1, 0, 1)
          if (funcName === 'SIGN') {
            const num = parseFloat(evaluateFormula('=' + args[0], sheetName)) || 0;
            return num > 0 ? 1 : num < 0 ? -1 : 0;
          }

          // PI - Pi constant
          if (funcName === 'PI') {
            return Math.PI;
          }

          // EXP - e^x
          if (funcName === 'EXP') {
            return Math.exp(parseFloat(evaluateFormula('=' + args[0], sheetName)) || 0);
          }

          // LN - Natural log
          if (funcName === 'LN') {
            const val = parseFloat(evaluateFormula('=' + args[0], sheetName)) || 0;
            return val > 0 ? Math.log(val) : '#NUM!';
          }

          // LOG - Logarithm (base 10 default)
          if (funcName === 'LOG') {
            const num = parseFloat(evaluateFormula('=' + args[0], sheetName)) || 0;
            const base = args[1] ? parseFloat(args[1]) : 10;
            return num > 0 ? Math.log(num) / Math.log(base) : '#NUM!';
          }

          // LOG10 - Base 10 logarithm
          if (funcName === 'LOG10') {
            const val = parseFloat(evalValue(args[0], sheetName));
            if (isNaN(val) || val <= 0) return '#NUM!';
            return Math.log10(val);
          }

          // ==================== TRIGONOMETRIC FUNCTIONS ====================

          // SIN - Sine (radians)
          if (funcName === 'SIN') {
            const val = parseFloat(evalValue(args[0], sheetName));
            return Math.sin(val);
          }

          // COS - Cosine (radians)
          if (funcName === 'COS') {
            const val = parseFloat(evalValue(args[0], sheetName));
            return Math.cos(val);
          }

          // TAN - Tangent (radians)
          if (funcName === 'TAN') {
            const val = parseFloat(evalValue(args[0], sheetName));
            return Math.tan(val);
          }

          // ASIN - Arcsine
          if (funcName === 'ASIN') {
            const val = parseFloat(evalValue(args[0], sheetName));
            if (val < -1 || val > 1) return '#NUM!';
            return Math.asin(val);
          }

          // ACOS - Arccosine
          if (funcName === 'ACOS') {
            const val = parseFloat(evalValue(args[0], sheetName));
            if (val < -1 || val > 1) return '#NUM!';
            return Math.acos(val);
          }

          // ATAN - Arctangent
          if (funcName === 'ATAN') {
            const val = parseFloat(evalValue(args[0], sheetName));
            return Math.atan(val);
          }

          // ATAN2 - Arctangent of x/y
          if (funcName === 'ATAN2') {
            const y = parseFloat(evalValue(args[0], sheetName));
            const x = parseFloat(evalValue(args[1], sheetName));
            return Math.atan2(y, x);
          }

          // SINH - Hyperbolic sine
          if (funcName === 'SINH') {
            const val = parseFloat(evalValue(args[0], sheetName));
            return Math.sinh(val);
          }

          // COSH - Hyperbolic cosine
          if (funcName === 'COSH') {
            const val = parseFloat(evalValue(args[0], sheetName));
            return Math.cosh(val);
          }

          // TANH - Hyperbolic tangent
          if (funcName === 'TANH') {
            const val = parseFloat(evalValue(args[0], sheetName));
            return Math.tanh(val);
          }

          // RADIANS - Convert degrees to radians
          if (funcName === 'RADIANS') {
            const deg = parseFloat(evalValue(args[0], sheetName));
            return deg * Math.PI / 180;
          }

          // DEGREES - Convert radians to degrees
          if (funcName === 'DEGREES') {
            const rad = parseFloat(evalValue(args[0], sheetName));
            return rad * 180 / Math.PI;
          }

          // ==================== FINANCIAL FUNCTIONS ====================

          // PMT - Payment for a loan
          if (funcName === 'PMT') {
            const rate = parseFloat(evalValue(args[0], sheetName));
            const nper = parseFloat(evalValue(args[1], sheetName));
            const pv = parseFloat(evalValue(args[2], sheetName));
            const fv = args[3] ? parseFloat(evalValue(args[3], sheetName)) : 0;
            const type = args[4] ? parseFloat(evalValue(args[4], sheetName)) : 0;

            if (rate === 0) return -(pv + fv) / nper;
            const pvif = Math.pow(1 + rate, nper);
            return -(rate * (pv * pvif + fv)) / (pvif - 1) / (1 + rate * type);
          }

          // FV - Future value
          if (funcName === 'FV') {
            const rate = parseFloat(evalValue(args[0], sheetName));
            const nper = parseFloat(evalValue(args[1], sheetName));
            const pmt = parseFloat(evalValue(args[2], sheetName)) || 0;
            const pv = parseFloat(evalValue(args[3], sheetName)) || 0;
            const type = args[4] ? parseFloat(evalValue(args[4], sheetName)) : 0;

            if (rate === 0) return -(pv + pmt * nper);
            const pvif = Math.pow(1 + rate, nper);
            return -(pv * pvif + pmt * (1 + rate * type) * (pvif - 1) / rate);
          }

          // PV - Present value
          if (funcName === 'PV') {
            const rate = parseFloat(evalValue(args[0], sheetName));
            const nper = parseFloat(evalValue(args[1], sheetName));
            const pmt = parseFloat(evalValue(args[2], sheetName)) || 0;
            const fv = parseFloat(evalValue(args[3], sheetName)) || 0;
            const type = args[4] ? parseFloat(evalValue(args[4], sheetName)) : 0;

            if (rate === 0) return -(fv + pmt * nper);
            const pvif = Math.pow(1 + rate, nper);
            return -(fv + pmt * (1 + rate * type) * (pvif - 1) / rate) / pvif;
          }

          // NPV - Net present value
          if (funcName === 'NPV') {
            const rate = parseFloat(evalValue(args[0], sheetName));
            let npv = 0;
            for (let i = 1; i < args.length; i++) {
              const arg = args[i];
              if (arg.includes(':')) {
                const [start, end] = arg.split(':');
                const vals = getNumericRange(sheetName, start, end);
                vals.forEach((v, idx) => {
                  npv += v / Math.pow(1 + rate, i + idx);
                });
              } else {
                const val = parseFloat(evalValue(arg, sheetName)) || 0;
                npv += val / Math.pow(1 + rate, i);
              }
            }
            return npv;
          }

          // IRR - Internal rate of return (simplified Newton-Raphson)
          if (funcName === 'IRR') {
            const values = [];
            for (const arg of args) {
              if (arg.includes(':')) {
                const [start, end] = arg.split(':');
                values.push(...getNumericRange(sheetName, start, end));
              } else {
                values.push(parseFloat(evalValue(arg, sheetName)) || 0);
              }
            }

            let guess = 0.1;
            for (let iter = 0; iter < 100; iter++) {
              let npv = 0, dnpv = 0;
              for (let i = 0; i < values.length; i++) {
                npv += values[i] / Math.pow(1 + guess, i);
                dnpv -= i * values[i] / Math.pow(1 + guess, i + 1);
              }
              if (Math.abs(npv) < 1e-10) return guess;
              guess = guess - npv / dnpv;
            }
            return '#NUM!';
          }

          // NPER - Number of periods
          if (funcName === 'NPER') {
            const rate = parseFloat(evalValue(args[0], sheetName));
            const pmt = parseFloat(evalValue(args[1], sheetName));
            const pv = parseFloat(evalValue(args[2], sheetName));
            const fv = args[3] ? parseFloat(evalValue(args[3], sheetName)) : 0;
            const type = args[4] ? parseFloat(evalValue(args[4], sheetName)) : 0;

            if (rate === 0) return -(pv + fv) / pmt;
            return Math.log((pmt * (1 + rate * type) - fv * rate) / (pv * rate + pmt * (1 + rate * type))) / Math.log(1 + rate);
          }

          // RATE - Interest rate (simplified Newton-Raphson)
          if (funcName === 'RATE') {
            const nper = parseFloat(evalValue(args[0], sheetName));
            const pmt = parseFloat(evalValue(args[1], sheetName));
            const pv = parseFloat(evalValue(args[2], sheetName));
            const fv = args[3] ? parseFloat(evalValue(args[3], sheetName)) : 0;

            let guess = 0.1;
            for (let iter = 0; iter < 100; iter++) {
              const pvif = Math.pow(1 + guess, nper);
              const y = pv * pvif + pmt * (pvif - 1) / guess + fv;
              const dy = pv * nper * Math.pow(1 + guess, nper - 1) + pmt * (nper * Math.pow(1 + guess, nper - 1) * guess - (pvif - 1)) / (guess * guess);
              if (Math.abs(y) < 1e-10) return guess;
              guess = guess - y / dy;
            }
            return '#NUM!';
          }

          // RAND - Random number 0-1
          if (funcName === 'RAND') {
            return Math.random();
          }

          // RANDBETWEEN - Random integer between
          if (funcName === 'RANDBETWEEN') {
            const min = parseInt(args[0]) || 0;
            const max = parseInt(args[1]) || 100;
            return Math.floor(Math.random() * (max - min + 1)) + min;
          }

          // PRODUCT - Multiply all values
          if (funcName === 'PRODUCT') {
            let product = 1;
            for (const arg of args) {
              if (arg.includes(':')) {
                const [start, end] = arg.split(':');
                getNumericRange(sheetName, start, end).forEach(v => product *= v);
              } else {
                product *= parseFloat(evaluateFormula('=' + arg, sheetName)) || 0;
              }
            }
            return product;
          }

          // SUMPRODUCT - Sum of products
          if (funcName === 'SUMPRODUCT') {
            const arrays = args.map(arg => {
              if (arg.includes(':')) {
                const [start, end] = arg.split(':');
                return getNumericRange(sheetName, start, end);
              }
              return [parseFloat(evaluateFormula('=' + arg, sheetName)) || 0];
            });
            const len = Math.min(...arrays.map(a => a.length));
            let sum = 0;
            for (let i = 0; i < len; i++) {
              let product = 1;
              arrays.forEach(arr => product *= arr[i] || 0);
              sum += product;
            }
            return sum;
          }

          // MEDIAN - Median value
          if (funcName === 'MEDIAN') {
            let values = [];
            for (const arg of args) {
              if (arg.includes(':')) {
                const [start, end] = arg.split(':');
                values = values.concat(getNumericRange(sheetName, start, end));
              } else {
                values.push(parseFloat(evaluateFormula('=' + arg, sheetName)) || 0);
              }
            }
            values.sort((a, b) => a - b);
            const mid = Math.floor(values.length / 2);
            return values.length % 2 ? values[mid] : (values[mid - 1] + values[mid]) / 2;
          }

          // MODE - Most frequent value
          if (funcName === 'MODE') {
            let values = [];
            for (const arg of args) {
              if (arg.includes(':')) {
                const [start, end] = arg.split(':');
                values = values.concat(getNumericRange(sheetName, start, end));
              }
            }
            const counts = {};
            values.forEach(v => counts[v] = (counts[v] || 0) + 1);
            let mode = values[0], maxCount = 0;
            for (const [val, count] of Object.entries(counts)) {
              if (count > maxCount) { mode = parseFloat(val); maxCount = count; }
            }
            return mode;
          }

          // STDEV - Standard deviation (sample)
          if (funcName === 'STDEV' || funcName === 'STDEV.S') {
            let values = [];
            for (const arg of args) {
              if (arg.includes(':')) {
                const [start, end] = arg.split(':');
                values = values.concat(getNumericRange(sheetName, start, end));
              }
            }
            if (values.length < 2) return '#DIV/0!';
            const mean = values.reduce((a, b) => a + b, 0) / values.length;
            const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / (values.length - 1);
            return Math.sqrt(variance);
          }

          // STDEVP - Standard deviation (population)
          if (funcName === 'STDEVP' || funcName === 'STDEV.P') {
            let values = [];
            for (const arg of args) {
              if (arg.includes(':')) {
                const [start, end] = arg.split(':');
                values = values.concat(getNumericRange(sheetName, start, end));
              }
            }
            if (values.length < 1) return '#DIV/0!';
            const mean = values.reduce((a, b) => a + b, 0) / values.length;
            const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / values.length;
            return Math.sqrt(variance);
          }

          // VAR - Variance (sample)
          if (funcName === 'VAR' || funcName === 'VAR.S') {
            let values = [];
            for (const arg of args) {
              if (arg.includes(':')) {
                const [start, end] = arg.split(':');
                values = values.concat(getNumericRange(sheetName, start, end));
              }
            }
            if (values.length < 2) return '#DIV/0!';
            const mean = values.reduce((a, b) => a + b, 0) / values.length;
            return values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / (values.length - 1);
          }

          // LARGE - Kth largest value
          if (funcName === 'LARGE') {
            const [start, end] = args[0].split(':');
            const k = parseInt(evaluateFormula('=' + args[1], sheetName)) || 1;
            const values = getNumericRange(sheetName, start, end).sort((a, b) => b - a);
            return k <= values.length ? values[k - 1] : '#NUM!';
          }

          // SMALL - Kth smallest value
          if (funcName === 'SMALL') {
            const [start, end] = args[0].split(':');
            const k = parseInt(evaluateFormula('=' + args[1], sheetName)) || 1;
            const values = getNumericRange(sheetName, start, end).sort((a, b) => a - b);
            return k <= values.length ? values[k - 1] : '#NUM!';
          }

          // PERCENTILE - Kth percentile
          if (funcName === 'PERCENTILE') {
            const [start, end] = args[0].split(':');
            const k = parseFloat(args[1]) || 0;
            const values = getNumericRange(sheetName, start, end).sort((a, b) => a - b);
            const index = k * (values.length - 1);
            const lower = Math.floor(index);
            const upper = Math.ceil(index);
            if (lower === upper) return values[lower];
            return values[lower] + (values[upper] - values[lower]) * (index - lower);
          }

          // ==================== LOGICAL FUNCTIONS ====================

          // IF - Conditional
          if (funcName === 'IF') {
            const condition = evaluateFormula('=' + args[0], sheetName);
            // Handle quoted strings directly
            let trueVal = true;
            let falseVal = false;
            if (args[1]) {
              if (args[1].startsWith('"') && args[1].endsWith('"')) {
                trueVal = args[1].slice(1, -1);
              } else {
                trueVal = evaluateFormula('=' + args[1], sheetName);
              }
            }
            if (args[2]) {
              if (args[2].startsWith('"') && args[2].endsWith('"')) {
                falseVal = args[2].slice(1, -1);
              } else {
                falseVal = evaluateFormula('=' + args[2], sheetName);
              }
            }
            return condition ? trueVal : falseVal;
          }

          // IFS - Multiple conditions
          if (funcName === 'IFS') {
            for (let i = 0; i < args.length; i += 2) {
              if (evaluateFormula('=' + args[i], sheetName)) {
                return evaluateFormula('=' + args[i + 1], sheetName);
              }
            }
            return '#N/A';
          }

          // IFERROR - Return value if error
          if (funcName === 'IFERROR') {
            try {
              const result = evaluateFormula('=' + args[0], sheetName);
              if (String(result).startsWith('#')) return evaluateFormula('=' + args[1], sheetName);
              return result;
            } catch {
              return evaluateFormula('=' + args[1], sheetName);
            }
          }

          // IFNA - Return value if #N/A
          if (funcName === 'IFNA') {
            const result = evaluateFormula('=' + args[0], sheetName);
            return result === '#N/A' ? evaluateFormula('=' + args[1], sheetName) : result;
          }

          // AND - All conditions true
          if (funcName === 'AND') {
            return args.every(arg => evaluateFormula('=' + arg, sheetName));
          }

          // OR - Any condition true
          if (funcName === 'OR') {
            return args.some(arg => evaluateFormula('=' + arg, sheetName));
          }

          // NOT - Negate
          if (funcName === 'NOT') {
            return !evaluateFormula('=' + args[0], sheetName);
          }

          // XOR - Exclusive or
          if (funcName === 'XOR') {
            const trueCount = args.filter(arg => evaluateFormula('=' + arg, sheetName)).length;
            return trueCount % 2 === 1;
          }

          // TRUE/FALSE constants
          if (funcName === 'TRUE') return true;
          if (funcName === 'FALSE') return false;

          // SWITCH - Switch/case
          if (funcName === 'SWITCH') {
            const value = evaluateFormula('=' + args[0], sheetName);
            for (let i = 1; i < args.length - 1; i += 2) {
              if (evaluateFormula('=' + args[i], sheetName) == value) {
                return evaluateFormula('=' + args[i + 1], sheetName);
              }
            }
            return args.length % 2 === 0 ? evaluateFormula('=' + args[args.length - 1], sheetName) : '#N/A';
          }

          // ==================== TEXT FUNCTIONS ====================

          // CONCATENATE / CONCAT - Join text
          if (funcName === 'CONCATENATE' || funcName === 'CONCAT') {
            return args.map(arg => {
              if (arg.startsWith('"') && arg.endsWith('"')) return arg.slice(1, -1);
              return String(evaluateFormula('=' + arg, sheetName));
            }).join('');
          }

          // TEXTJOIN - Join with delimiter
          if (funcName === 'TEXTJOIN') {
            const delimiter = args[0].replace(/^"|"$/g, '');
            const ignoreEmpty = args[1].toUpperCase() === 'TRUE';
            const values = args.slice(2).map(arg => {
              if (arg.includes(':')) {
                const [start, end] = arg.split(':');
                return getRangeValuesFlat(sheetName, start, end);
              }
              return [evaluateFormula('=' + arg, sheetName)];
            }).flat();
            const filtered = ignoreEmpty ? values.filter(v => v != null && v !== '') : values;
            return filtered.join(delimiter);
          }

          // LEFT - Left characters
          if (funcName === 'LEFT') {
            const text = String(evaluateFormula('=' + args[0], sheetName));
            const num = parseInt(args[1]) || 1;
            return text.substring(0, num);
          }

          // RIGHT - Right characters
          if (funcName === 'RIGHT') {
            const text = String(evaluateFormula('=' + args[0], sheetName));
            const num = parseInt(args[1]) || 1;
            return text.substring(text.length - num);
          }

          // MID - Middle characters
          if (funcName === 'MID') {
            const text = String(evaluateFormula('=' + args[0], sheetName));
            const start = parseInt(args[1]) || 1;
            const num = parseInt(args[2]) || 1;
            return text.substring(start - 1, start - 1 + num);
          }

          // LEN - Length of text
          if (funcName === 'LEN') {
            return String(evaluateFormula('=' + args[0], sheetName)).length;
          }

          // TRIM - Remove extra spaces
          if (funcName === 'TRIM') {
            return String(evalValue(args[0], sheetName)).trim().replace(/\s+/g, ' ');
          }

          // UPPER - Uppercase
          if (funcName === 'UPPER') {
            return String(evaluateFormula('=' + args[0], sheetName)).toUpperCase();
          }

          // LOWER - Lowercase
          if (funcName === 'LOWER') {
            return String(evaluateFormula('=' + args[0], sheetName)).toLowerCase();
          }

          // PROPER - Title case
          if (funcName === 'PROPER') {
            return String(evaluateFormula('=' + args[0], sheetName))
              .toLowerCase()
              .replace(/\b\w/g, c => c.toUpperCase());
          }

          // FIND - Find text (case-sensitive)
          if (funcName === 'FIND') {
            const findText = args[0].replace(/^"|"$/g, '');
            const withinText = String(evaluateFormula('=' + args[1], sheetName));
            const startNum = parseInt(args[2]) || 1;
            const pos = withinText.indexOf(findText, startNum - 1);
            return pos >= 0 ? pos + 1 : '#VALUE!';
          }

          // SEARCH - Find text (case-insensitive)
          if (funcName === 'SEARCH') {
            const findText = args[0].replace(/^"|"$/g, '').toLowerCase();
            const withinText = String(evaluateFormula('=' + args[1], sheetName)).toLowerCase();
            const startNum = parseInt(args[2]) || 1;
            const pos = withinText.indexOf(findText, startNum - 1);
            return pos >= 0 ? pos + 1 : '#VALUE!';
          }

          // REPLACE - Replace by position
          if (funcName === 'REPLACE') {
            const text = String(evaluateFormula('=' + args[0], sheetName));
            const start = parseInt(args[1]) || 1;
            const num = parseInt(args[2]) || 0;
            const newText = args[3].replace(/^"|"$/g, '');
            return text.substring(0, start - 1) + newText + text.substring(start - 1 + num);
          }

          // SUBSTITUTE - Replace text
          if (funcName === 'SUBSTITUTE') {
            let text = String(evaluateFormula('=' + args[0], sheetName));
            const oldText = args[1].replace(/^"|"$/g, '');
            const newText = args[2].replace(/^"|"$/g, '');
            const instance = args[3] ? parseInt(args[3]) : 0;
            if (instance === 0) {
              return text.split(oldText).join(newText);
            } else {
              let count = 0;
              return text.replace(new RegExp(oldText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), match => {
                count++;
                return count === instance ? newText : match;
              });
            }
          }

          // REPT - Repeat text
          if (funcName === 'REPT') {
            const text = String(evalValue(args[0], sheetName));
            const times = parseInt(evalValue(args[1], sheetName)) || 0;
            return text.repeat(times);
          }

          // TEXT - Format number as text
          if (funcName === 'TEXT') {
            const value = parseFloat(evaluateFormula('=' + args[0], sheetName)) || 0;
            const format = args[1].replace(/^"|"$/g, '');
            // Simple format handling
            if (format.includes('%')) return (value * 100).toFixed(format.split('.')[1]?.length || 0) + '%';
            if (format.includes('.')) {
              const decimals = format.split('.')[1]?.replace(/[^0#]/g, '').length || 0;
              return value.toFixed(decimals);
            }
            return String(value);
          }

          // VALUE - Convert text to number
          if (funcName === 'VALUE') {
            const text = String(evaluateFormula('=' + args[0], sheetName)).replace(/[,$%]/g, '');
            return parseFloat(text) || '#VALUE!';
          }

          // EXACT - Compare text (case-sensitive)
          if (funcName === 'EXACT') {
            return String(evaluateFormula('=' + args[0], sheetName)) === String(evaluateFormula('=' + args[1], sheetName));
          }

          // ==================== LOOKUP FUNCTIONS ====================

          // VLOOKUP - Vertical lookup
          if (funcName === 'VLOOKUP') {
            const lookupValue = evaluateFormula('=' + args[0], sheetName);
            const [rangeStart, rangeEnd] = args[1].split(':');
            const colIndex = parseInt(args[2]) || 1;
            const exactMatch = args[3] ? args[3].toUpperCase() !== 'TRUE' && args[3] !== '1' : true;

            const startRef = parseCellRef(rangeStart);
            const endRef = parseCellRef(rangeEnd);
            if (!startRef || !endRef) return '#REF!';

            for (let r = startRef.row; r <= endRef.row; r++) {
              const cellData = getCellDataInternal(sheetName, r, startRef.col);
              const cellVal = cellData?.v?.v ?? cellData?.v;

              if (exactMatch ? cellVal == lookupValue : cellVal <= lookupValue) {
                if (!exactMatch) {
                  // For approximate match, find the largest value <= lookupValue
                  let bestRow = r;
                  for (let r2 = r + 1; r2 <= endRef.row; r2++) {
                    const nextData = getCellDataInternal(sheetName, r2, startRef.col);
                    const nextVal = nextData?.v?.v ?? nextData?.v;
                    if (nextVal <= lookupValue && nextVal > cellVal) bestRow = r2;
                    else if (nextVal > lookupValue) break;
                  }
                  r = bestRow;
                }
                const resultData = getCellDataInternal(sheetName, r, startRef.col + colIndex - 1);
                return resultData?.v?.v ?? resultData?.v ?? '';
              }
            }
            return '#N/A';
          }

          // HLOOKUP - Horizontal lookup
          if (funcName === 'HLOOKUP') {
            const lookupValue = evaluateFormula('=' + args[0], sheetName);
            const [rangeStart, rangeEnd] = args[1].split(':');
            const rowIndex = parseInt(args[2]) || 1;
            const exactMatch = args[3] ? args[3].toUpperCase() !== 'TRUE' : true;

            const startRef = parseCellRef(rangeStart);
            const endRef = parseCellRef(rangeEnd);
            if (!startRef || !endRef) return '#REF!';

            for (let c = startRef.col; c <= endRef.col; c++) {
              const cellData = getCellDataInternal(sheetName, startRef.row, c);
              const cellVal = cellData?.v?.v ?? cellData?.v;

              if (exactMatch ? cellVal == lookupValue : true) {
                const resultData = getCellDataInternal(sheetName, startRef.row + rowIndex - 1, c);
                return resultData?.v?.v ?? resultData?.v ?? '';
              }
            }
            return '#N/A';
          }

          // INDEX - Get value at position
          if (funcName === 'INDEX') {
            const [rangeStart, rangeEnd] = args[0].split(':');
            const startRef = parseCellRef(rangeStart);
            const endRef = rangeEnd ? parseCellRef(rangeEnd) : startRef;
            if (!startRef) return '#REF!';

            // Determine if range is 1D horizontal (same row), 1D vertical (same col), or 2D
            const isHorizontal = startRef.row === endRef.row;
            const isVertical = startRef.col === endRef.col;

            let rowNum, colNum;
            if (args.length === 2 && (isHorizontal || isVertical)) {
              // Single number for 1D range - use as column for horizontal, row for vertical
              const idx = parseInt(evalValue(args[1], sheetName)) || 1;
              if (isHorizontal) {
                rowNum = 1;
                colNum = idx;
              } else {
                rowNum = idx;
                colNum = 1;
              }
            } else {
              rowNum = parseInt(evalValue(args[1], sheetName)) || 1;
              colNum = args[2] ? parseInt(evalValue(args[2], sheetName)) : 1;
            }

            const cellData = getCellDataInternal(sheetName, startRef.row + rowNum - 1, startRef.col + colNum - 1);
            return cellData?.v?.v ?? cellData?.v ?? '';
          }

          // MATCH - Find position
          if (funcName === 'MATCH') {
            const lookupValue = evaluateFormula('=' + args[0], sheetName);
            const [rangeStart, rangeEnd] = args[1].split(':');
            const matchType = args[2] ? parseInt(args[2]) : 1;

            const startRef = parseCellRef(rangeStart);
            const endRef = parseCellRef(rangeEnd);
            if (!startRef || !endRef) return '#REF!';

            const isRow = startRef.row === endRef.row;
            const values = [];

            if (isRow) {
              for (let c = startRef.col; c <= endRef.col; c++) {
                const cellData = getCellDataInternal(sheetName, startRef.row, c);
                values.push(cellData?.v?.v ?? cellData?.v);
              }
            } else {
              for (let r = startRef.row; r <= endRef.row; r++) {
                const cellData = getCellDataInternal(sheetName, r, startRef.col);
                values.push(cellData?.v?.v ?? cellData?.v);
              }
            }

            if (matchType === 0) {
              // Exact match
              const idx = values.findIndex(v => v == lookupValue);
              return idx >= 0 ? idx + 1 : '#N/A';
            } else if (matchType === 1) {
              // Largest value <= lookup (assumes sorted ascending)
              let lastIdx = -1;
              for (let i = 0; i < values.length; i++) {
                if (values[i] <= lookupValue) lastIdx = i;
                else break;
              }
              return lastIdx >= 0 ? lastIdx + 1 : '#N/A';
            } else {
              // Smallest value >= lookup (assumes sorted descending)
              let lastIdx = -1;
              for (let i = 0; i < values.length; i++) {
                if (values[i] >= lookupValue) lastIdx = i;
                else break;
              }
              return lastIdx >= 0 ? lastIdx + 1 : '#N/A';
            }
          }

          // CHOOSE - Choose from list
          if (funcName === 'CHOOSE') {
            const index = parseInt(evaluateFormula('=' + args[0], sheetName)) || 0;
            if (index < 1 || index >= args.length) return '#VALUE!';
            return evaluateFormula('=' + args[index], sheetName);
          }

          // LOOKUP - Simple lookup
          if (funcName === 'LOOKUP') {
            const lookupValue = evaluateFormula('=' + args[0], sheetName);
            const [lookStart, lookEnd] = args[1].split(':');
            const resultRange = args[2] ? args[2].split(':') : null;

            const startRef = parseCellRef(lookStart);
            const endRef = parseCellRef(lookEnd);
            if (!startRef || !endRef) return '#REF!';

            const isRow = startRef.row === endRef.row;
            let foundIdx = -1;

            if (isRow) {
              for (let c = startRef.col; c <= endRef.col; c++) {
                const cellData = getCellDataInternal(sheetName, startRef.row, c);
                const cellVal = cellData?.v?.v ?? cellData?.v;
                if (cellVal <= lookupValue) foundIdx = c - startRef.col;
              }
            } else {
              for (let r = startRef.row; r <= endRef.row; r++) {
                const cellData = getCellDataInternal(sheetName, r, startRef.col);
                const cellVal = cellData?.v?.v ?? cellData?.v;
                if (cellVal <= lookupValue) foundIdx = r - startRef.row;
              }
            }

            if (foundIdx < 0) return '#N/A';

            if (resultRange) {
              const resultStart = parseCellRef(resultRange[0]);
              if (!resultStart) return '#REF!';
              const resultIsRow = resultRange[1] ? parseCellRef(resultRange[0]).row === parseCellRef(resultRange[1]).row : true;
              if (resultIsRow) {
                const cellData = getCellDataInternal(sheetName, resultStart.row, resultStart.col + foundIdx);
                return cellData?.v?.v ?? cellData?.v ?? '';
              } else {
                const cellData = getCellDataInternal(sheetName, resultStart.row + foundIdx, resultStart.col);
                return cellData?.v?.v ?? cellData?.v ?? '';
              }
            }
            return foundIdx + 1;
          }

          // ==================== CONDITIONAL FUNCTIONS ====================

          // COUNTIF - Count with condition
          if (funcName === 'COUNTIF') {
            const [start, end] = args[0].split(':');
            let criteria = args[1].replace(/^"|"$/g, '');
            if (parseCellRef(args[1])) criteria = getCellByRef(sheetName, args[1]);

            const values = getRangeValuesFlat(sheetName, start, end);
            return values.filter(v => matchesCriteria(v, criteria)).length;
          }

          // COUNTIFS - Count with multiple conditions
          if (funcName === 'COUNTIFS') {
            const ranges = [];
            const criteriaList = [];
            for (let i = 0; i < args.length; i += 2) {
              ranges.push(args[i].split(':'));
              criteriaList.push(args[i + 1].replace(/^"|"$/g, ''));
            }

            const firstRange = getRangeValuesFlat(sheetName, ranges[0][0], ranges[0][1]);
            let count = 0;

            for (let i = 0; i < firstRange.length; i++) {
              let allMatch = true;
              for (let j = 0; j < ranges.length; j++) {
                const rangeVals = getRangeValuesFlat(sheetName, ranges[j][0], ranges[j][1]);
                if (!matchesCriteria(rangeVals[i], criteriaList[j])) {
                  allMatch = false;
                  break;
                }
              }
              if (allMatch) count++;
            }
            return count;
          }

          // SUMIF - Sum with condition
          if (funcName === 'SUMIF') {
            const [start, end] = args[0].split(':');
            let criteria = args[1].replace(/^"|"$/g, '');
            if (parseCellRef(args[1])) criteria = getCellByRef(sheetName, args[1]);
            const sumRange = args[2] ? args[2].split(':') : [start, end];

            const values = getRangeValuesFlat(sheetName, start, end);
            const sumValues = getRangeValuesFlat(sheetName, sumRange[0], sumRange[1] || sumRange[0]);

            let sum = 0;
            for (let i = 0; i < values.length; i++) {
              if (matchesCriteria(values[i], criteria)) {
                sum += parseFloat(sumValues[i]) || 0;
              }
            }
            return sum;
          }

          // SUMIFS - Sum with multiple conditions
          if (funcName === 'SUMIFS') {
            const sumRangeParts = args[0].split(':');
            const sumValues = getRangeValuesFlat(sheetName, sumRangeParts[0], sumRangeParts[1]);

            const ranges = [];
            const criteriaList = [];
            for (let i = 1; i < args.length; i += 2) {
              ranges.push(args[i].split(':'));
              criteriaList.push(args[i + 1].replace(/^"|"$/g, ''));
            }

            let sum = 0;
            for (let i = 0; i < sumValues.length; i++) {
              let allMatch = true;
              for (let j = 0; j < ranges.length; j++) {
                const rangeVals = getRangeValuesFlat(sheetName, ranges[j][0], ranges[j][1]);
                if (!matchesCriteria(rangeVals[i], criteriaList[j])) {
                  allMatch = false;
                  break;
                }
              }
              if (allMatch) sum += parseFloat(sumValues[i]) || 0;
            }
            return sum;
          }

          // AVERAGEIF - Average with condition
          if (funcName === 'AVERAGEIF') {
            const [start, end] = args[0].split(':');
            let criteria = args[1].replace(/^"|"$/g, '');
            const avgRange = args[2] ? args[2].split(':') : [start, end];

            const values = getRangeValuesFlat(sheetName, start, end);
            const avgValues = getRangeValuesFlat(sheetName, avgRange[0], avgRange[1] || avgRange[0]);

            let sum = 0, count = 0;
            for (let i = 0; i < values.length; i++) {
              if (matchesCriteria(values[i], criteria)) {
                const num = parseFloat(avgValues[i]);
                if (!isNaN(num)) { sum += num; count++; }
              }
            }
            return count > 0 ? sum / count : '#DIV/0!';
          }

          // MAXIFS - Max with conditions
          if (funcName === 'MAXIFS') {
            const maxRangeParts = args[0].split(':');
            const maxValues = getNumericRange(sheetName, maxRangeParts[0], maxRangeParts[1]);

            const ranges = [];
            const criteriaList = [];
            for (let i = 1; i < args.length; i += 2) {
              ranges.push(args[i].split(':'));
              criteriaList.push(args[i + 1].replace(/^"|"$/g, ''));
            }

            let max = -Infinity;
            for (let i = 0; i < maxValues.length; i++) {
              let allMatch = true;
              for (let j = 0; j < ranges.length; j++) {
                const rangeVals = getRangeValuesFlat(sheetName, ranges[j][0], ranges[j][1]);
                if (!matchesCriteria(rangeVals[i], criteriaList[j])) {
                  allMatch = false;
                  break;
                }
              }
              if (allMatch && maxValues[i] > max) max = maxValues[i];
            }
            return max === -Infinity ? 0 : max;
          }

          // MINIFS - Min with conditions
          if (funcName === 'MINIFS') {
            const minRangeParts = args[0].split(':');
            const minValues = getNumericRange(sheetName, minRangeParts[0], minRangeParts[1]);

            const ranges = [];
            const criteriaList = [];
            for (let i = 1; i < args.length; i += 2) {
              ranges.push(args[i].split(':'));
              criteriaList.push(args[i + 1].replace(/^"|"$/g, ''));
            }

            let min = Infinity;
            for (let i = 0; i < minValues.length; i++) {
              let allMatch = true;
              for (let j = 0; j < ranges.length; j++) {
                const rangeVals = getRangeValuesFlat(sheetName, ranges[j][0], ranges[j][1]);
                if (!matchesCriteria(rangeVals[i], criteriaList[j])) {
                  allMatch = false;
                  break;
                }
              }
              if (allMatch && minValues[i] < min) min = minValues[i];
            }
            return min === Infinity ? 0 : min;
          }

          // ==================== DATE FUNCTIONS ====================

          // TODAY - Current date
          if (funcName === 'TODAY') {
            const d = new Date();
            return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;
          }

          // NOW - Current date and time
          if (funcName === 'NOW') {
            return new Date().toISOString();
          }

          // DATE - Create date
          if (funcName === 'DATE') {
            const year = parseInt(evaluateFormula('=' + args[0], sheetName)) || 2000;
            const month = parseInt(evaluateFormula('=' + args[1], sheetName)) || 1;
            const day = parseInt(evaluateFormula('=' + args[2], sheetName)) || 1;
            return new Date(year, month - 1, day).toISOString().split('T')[0];
          }

          // YEAR - Extract year
          if (funcName === 'YEAR') {
            const dateVal = evaluateFormula('=' + args[0], sheetName);
            return new Date(dateVal).getFullYear();
          }

          // MONTH - Extract month
          if (funcName === 'MONTH') {
            const dateVal = evaluateFormula('=' + args[0], sheetName);
            return new Date(dateVal).getMonth() + 1;
          }

          // DAY - Extract day
          if (funcName === 'DAY') {
            const dateVal = evaluateFormula('=' + args[0], sheetName);
            return new Date(dateVal).getDate();
          }

          // WEEKDAY - Day of week
          if (funcName === 'WEEKDAY') {
            const dateVal = evaluateFormula('=' + args[0], sheetName);
            const returnType = parseInt(args[1]) || 1;
            const day = new Date(dateVal).getDay();
            if (returnType === 1) return day + 1; // Sunday = 1
            if (returnType === 2) return day === 0 ? 7 : day; // Monday = 1
            return day; // Sunday = 0
          }

          // HOUR - Extract hour
          if (funcName === 'HOUR') {
            const dateVal = evaluateFormula('=' + args[0], sheetName);
            return new Date(dateVal).getHours();
          }

          // MINUTE - Extract minute
          if (funcName === 'MINUTE') {
            const dateVal = evaluateFormula('=' + args[0], sheetName);
            return new Date(dateVal).getMinutes();
          }

          // SECOND - Extract second
          if (funcName === 'SECOND') {
            const dateVal = evaluateFormula('=' + args[0], sheetName);
            return new Date(dateVal).getSeconds();
          }

          // DATEDIF - Difference between dates
          if (funcName === 'DATEDIF') {
            const startDate = new Date(evaluateFormula('=' + args[0], sheetName));
            const endDate = new Date(evaluateFormula('=' + args[1], sheetName));
            const unit = args[2].replace(/^"|"$/g, '').toUpperCase();
            const diffTime = endDate - startDate;
            const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));

            if (unit === 'D') return diffDays;
            if (unit === 'M') return Math.floor(diffDays / 30);
            if (unit === 'Y') return Math.floor(diffDays / 365);
            return diffDays;
          }

          // EDATE - Add months to date
          if (funcName === 'EDATE') {
            const startDate = new Date(evaluateFormula('=' + args[0], sheetName));
            const months = parseInt(evaluateFormula('=' + args[1], sheetName)) || 0;
            startDate.setMonth(startDate.getMonth() + months);
            return startDate.toISOString().split('T')[0];
          }

          // EOMONTH - End of month
          if (funcName === 'EOMONTH') {
            const startDate = new Date(evaluateFormula('=' + args[0], sheetName));
            const months = parseInt(evaluateFormula('=' + args[1], sheetName)) || 0;
            startDate.setMonth(startDate.getMonth() + months + 1, 0);
            return startDate.toISOString().split('T')[0];
          }

          // ==================== INFO FUNCTIONS ====================

          // ISBLANK - Check if empty
          if (funcName === 'ISBLANK') {
            const val = evaluateFormula('=' + args[0], sheetName);
            return val == null || val === '';
          }

          // ISNUMBER - Check if number
          if (funcName === 'ISNUMBER') {
            const val = evaluateFormula('=' + args[0], sheetName);
            return typeof val === 'number' && !isNaN(val);
          }

          // ISTEXT - Check if text
          if (funcName === 'ISTEXT') {
            const val = evaluateFormula('=' + args[0], sheetName);
            return typeof val === 'string' && isNaN(parseFloat(val));
          }

          // ISERROR - Check if error
          if (funcName === 'ISERROR') {
            const val = evaluateFormula('=' + args[0], sheetName);
            return String(val).startsWith('#');
          }

          // ISNA - Check if #N/A
          if (funcName === 'ISNA') {
            return evaluateFormula('=' + args[0], sheetName) === '#N/A';
          }

          // ISEVEN - Check if even
          if (funcName === 'ISEVEN') {
            const val = parseFloat(evaluateFormula('=' + args[0], sheetName)) || 0;
            return Math.floor(val) % 2 === 0;
          }

          // ISODD - Check if odd
          if (funcName === 'ISODD') {
            const val = parseFloat(evaluateFormula('=' + args[0], sheetName)) || 0;
            return Math.floor(val) % 2 !== 0;
          }

          // TYPE - Return type code
          if (funcName === 'TYPE') {
            const val = evaluateFormula('=' + args[0], sheetName);
            if (typeof val === 'number') return 1;
            if (typeof val === 'string') return 2;
            if (typeof val === 'boolean') return 4;
            if (String(val).startsWith('#')) return 16;
            return 64; // Array
          }

          // ROW - Return row number
          if (funcName === 'ROW') {
            if (args.length === 0) return selectedCell.row + 1;
            const ref = parseCellRef(args[0]);
            return ref ? ref.row + 1 : '#REF!';
          }

          // COLUMN - Return column number
          if (funcName === 'COLUMN') {
            if (args.length === 0) return selectedCell.col + 1;
            const ref = parseCellRef(args[0]);
            return ref ? ref.col + 1 : '#REF!';
          }

          // ROWS - Count rows in range
          if (funcName === 'ROWS') {
            const [start, end] = args[0].split(':');
            const s = parseCellRef(start);
            const e = parseCellRef(end);
            return e.row - s.row + 1;
          }

          // COLUMNS - Count columns in range
          if (funcName === 'COLUMNS') {
            const [start, end] = args[0].split(':');
            const s = parseCellRef(start);
            const e = parseCellRef(end);
            return e.col - s.col + 1;
          }

          // N - Convert to number
          if (funcName === 'N') {
            const val = evaluateFormula('=' + args[0], sheetName);
            if (typeof val === 'number') return val;
            if (typeof val === 'boolean') return val ? 1 : 0;
            return 0;
          }

          // NA - Return #N/A
          if (funcName === 'NA') {
            return '#N/A';
          }

          // Unknown function - try to evaluate as expression
          console.warn('[Formula] Unknown function:', funcName);
        }

        // Handle simple cell reference
        const cellRefMatch = expr.match(/^([A-Z]+)(\d+)$/i);
        if (cellRefMatch) {
          return getCellByRef(sheetName, expr.toUpperCase());
        }

        // Safe expression evaluator - no eval/Function required
        // Supports: +, -, *, /, ^, %, (), comparisons (=, <, >, <=, >=, <>)
        function safeEval(expr, sheetName) {
          // Replace cell references with values
          let processed = expr.replace(/([A-Z]+)(\d+)/gi, (match) => {
            const val = getCellByRef(sheetName, match.toUpperCase());
            if (typeof val === 'string' && isNaN(parseFloat(val))) {
              return JSON.stringify(val);
            }
            return val ?? 0;
          });

          // Tokenize the expression
          const tokens = [];
          let i = 0;
          while (i < processed.length) {
            const ch = processed[i];

            // Skip whitespace
            if (/\s/.test(ch)) { i++; continue; }

            // Number (including decimals and negative)
            if (/[\d.]/.test(ch) || (ch === '-' && (tokens.length === 0 || ['(', '+', '-', '*', '/', '^', '%', '<', '>', '='].includes(tokens[tokens.length - 1])))) {
              let num = '';
              if (ch === '-') { num = '-'; i++; }
              while (i < processed.length && /[\d.eE+-]/.test(processed[i])) {
                // Handle scientific notation carefully
                if ((processed[i] === '+' || processed[i] === '-') && !/[eE]/.test(num[num.length - 1])) break;
                num += processed[i++];
              }
              tokens.push(parseFloat(num));
              continue;
            }

            // String literal
            if (ch === '"') {
              let str = '';
              i++; // skip opening quote
              while (i < processed.length && processed[i] !== '"') {
                if (processed[i] === '\\' && i + 1 < processed.length) {
                  i++; str += processed[i++];
                } else {
                  str += processed[i++];
                }
              }
              i++; // skip closing quote
              tokens.push(str);
              continue;
            }

            // Operators
            if (ch === '<' && processed[i+1] === '>') { tokens.push('<>'); i += 2; continue; }
            if (ch === '<' && processed[i+1] === '=') { tokens.push('<='); i += 2; continue; }
            if (ch === '>' && processed[i+1] === '=') { tokens.push('>='); i += 2; continue; }
            if (/[+\-*\/^%()<>=]/.test(ch)) { tokens.push(ch); i++; continue; }

            // TRUE/FALSE
            if (processed.substring(i, i+4).toUpperCase() === 'TRUE') {
              tokens.push(true); i += 4; continue;
            }
            if (processed.substring(i, i+5).toUpperCase() === 'FALSE') {
              tokens.push(false); i += 5; continue;
            }

            // Unknown character - error
            throw new Error('Unexpected character: ' + ch);
          }

          // Simple recursive descent parser
          let pos = 0;

          function parseExpr() { return parseComparison(); }

          function parseComparison() {
            let left = parseAddSub();
            while (pos < tokens.length && ['=', '<', '>', '<=', '>=', '<>'].includes(tokens[pos])) {
              const op = tokens[pos++];
              const right = parseAddSub();
              switch (op) {
                case '=': left = left === right; break;
                case '<': left = left < right; break;
                case '>': left = left > right; break;
                case '<=': left = left <= right; break;
                case '>=': left = left >= right; break;
                case '<>': left = left !== right; break;
              }
            }
            return left;
          }

          function parseAddSub() {
            let left = parseMulDiv();
            while (pos < tokens.length && (tokens[pos] === '+' || tokens[pos] === '-')) {
              const op = tokens[pos++];
              const right = parseMulDiv();
              left = op === '+' ? left + right : left - right;
            }
            return left;
          }

          function parseMulDiv() {
            let left = parsePower();
            while (pos < tokens.length && (tokens[pos] === '*' || tokens[pos] === '/' || tokens[pos] === '%')) {
              const op = tokens[pos++];
              const right = parsePower();
              if (op === '*') left = left * right;
              else if (op === '/') left = right !== 0 ? left / right : '#DIV/0!';
              else left = left % right;
            }
            return left;
          }

          function parsePower() {
            let left = parseUnary();
            while (pos < tokens.length && tokens[pos] === '^') {
              pos++;
              const right = parseUnary();
              left = Math.pow(left, right);
            }
            return left;
          }

          function parseUnary() {
            if (tokens[pos] === '-') {
              pos++;
              return -parseUnary();
            }
            if (tokens[pos] === '+') {
              pos++;
              return parseUnary();
            }
            return parsePrimary();
          }

          function parsePrimary() {
            if (tokens[pos] === '(') {
              pos++; // skip (
              const val = parseExpr();
              if (tokens[pos] === ')') pos++; // skip )
              return val;
            }
            return tokens[pos++];
          }

          return parseExpr();
        }

        // Use safe expression evaluator
        try {
          const result = safeEval(expr, sheetName);
          return result;
        } catch (evalError) {
          console.error('[Formula] Eval error for:', expr, evalError);
          window._lastFormulaError = { expr, error: evalError.message };
          return '#ERROR!';
        }
      } catch (e) {
        console.error('[Formula] Error evaluating:', formula, e);
        // Store the error in a global for debugging
        window._lastFormulaError = { formula, error: e.message, stack: e.stack };
        return '#ERROR!';
      }
    }

    // File operations (stub - actual implementation in main process)
    window.openFile = async (filePath) => {
      // This will be handled by the main process via IPC
      console.log('[Spreadsheet] Opening file:', filePath);
      return { success: false, error: 'Use IPC for file operations' };
    };

    window.saveFile = async (filePath, data) => {
      console.log('[Spreadsheet] Saving file:', filePath);
      return { success: false, error: 'Use IPC for file operations' };
    };

    window.exportAs = async (format, filePath, data) => {
      console.log('[Spreadsheet] Exporting as:', format, filePath);
      return { success: false, error: 'Use IPC for file operations' };
    };

    // Initialize on load
    document.addEventListener('DOMContentLoaded', initSpreadsheet);
  </script>
</body>
</html>
